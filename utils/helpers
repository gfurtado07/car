const { Client } = require('pg');
const config = require('../config');

let client;

/**
 * Inicializa a conex√£o com o PostgreSQL e garante que a tabela 'usuarios' exista.
 */
async function inicializarBancoDados() {
  if (client) return client;

  client = new Client({
    connectionString: process.env.DATABASE_URL
  });

  try {
    await client.connect();
    
    // Cria tabela se n√£o existir
    await client.query(`
      CREATE TABLE IF NOT EXISTS usuarios (
        telegram_id BIGINT PRIMARY KEY,
        nome TEXT NOT NULL,
        email TEXT,
        root_id BIGINT
      );
    `);
    
    // Verifica se a coluna root_id existe e qual seu tipo
    const colunaInfo = await client.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'usuarios' AND column_name = 'root_id';
    `);

    if (colunaInfo.rows.length === 0) {
      // Coluna n√£o existe, cria como BIGINT
      await client.query(`ALTER TABLE usuarios ADD COLUMN root_id BIGINT;`);
      console.log('‚úÖ Coluna root_id criada como BIGINT');
    } else if (colunaInfo.rows[0].data_type === 'text') {
      // Coluna existe mas √© TEXT, converte para BIGINT
      console.log('üîÑ Convertendo coluna root_id de TEXT para BIGINT...');
      
      // Primeiro, limpa valores inv√°lidos (n√£o num√©ricos)
      await client.query(`
        UPDATE usuarios 
        SET root_id = NULL 
        WHERE root_id IS NOT NULL 
        AND root_id !~ '^[0-9]+$';
      `);
      
      // Converte o tipo da coluna
      await client.query(`
        ALTER TABLE usuarios 
        ALTER COLUMN root_id TYPE BIGINT 
        USING CASE 
          WHEN root_id ~ '^[0-9]+$' THEN root_id::BIGINT 
          ELSE NULL 
        END;
      `);
      
      console.log('‚úÖ Coluna root_id convertida para BIGINT com sucesso');
    } else {
      console.log('‚úÖ Coluna root_id j√° existe como BIGINT');
    }
    
    console.log('‚úÖ PostgreSQL conectado e tabela "usuarios" pronta com root_id BIGINT.');
    return client;
  } catch (error) {
    console.error('‚ùå Erro ao conectar no PostgreSQL:', error);
    throw error;
  }
}

/**
 * Insere ou atualiza um usu√°rio na tabela 'usuarios'.
 */
async function salvarUsuario(telegramId, nome, email = null, rootId = null) {
  if (!client) await inicializarBancoDados();
  try {
    // Converte rootId para n√∫mero ou null
    const rootIdNumber = rootId !== null && rootId !== undefined ? Number(rootId) : null;
    
    const res = await client.query(
      `INSERT INTO usuarios (telegram_id, nome, email, root_id) 
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (telegram_id) 
       DO UPDATE SET 
         nome = $2, 
         email = COALESCE($3, usuarios.email),
         root_id = COALESCE($4, usuarios.root_id)
       RETURNING *;`,
      [telegramId, nome, email, rootIdNumber]
    );
    return res.rows[0];
  } catch (error) {
    console.error('‚ùå Erro ao salvar usu√°rio:', error);
    return null;
  }
}

/**
 * Atualiza apenas o root_id de um usu√°rio
 */
async function atualizarRootId(telegramId, rootId) {
  if (!client) await inicializarBancoDados();
  try {
    // Converte rootId para n√∫mero ou null
    const rootIdNumber = rootId !== null && rootId !== undefined ? Number(rootId) : null;
    
    const res = await client.query(
      `UPDATE usuarios SET root_id = $1 WHERE telegram_id = $2 RETURNING *;`,
      [rootIdNumber, telegramId]
    );
    return res.rows[0] || null;
  } catch (error) {
    console.error('‚ùå Erro ao atualizar root_id:', error);
    return null;
  }
}

/**
 * Busca um usu√°rio pelo telegram_id.
 */
async function buscarUsuario(telegramId) {
  if (!client) await inicializarBancoDados();
  try {
    const res = await client.query(
      `SELECT * FROM usuarios WHERE telegram_id = $1;`,
      [telegramId]
    );
    return res.rows[0] || null;
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio:', error);
    return null;
  }
}

module.exports = {
  inicializarBancoDados,
  salvarUsuario,
  buscarUsuario,
  atualizarRootId,
  client
};


